"use strict";(self.webpackChunkphysical_ai_textbook=self.webpackChunkphysical_ai_textbook||[]).push([[2761],{8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var t=s(6540);const o={},r=t.createContext(o);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},8455:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-1/ros2-fundamentals","title":"ROS 2 Fundamentals","description":"Deep dive into advanced ROS 2 concepts for building production-ready robotic systems. As a software developer, you\'re likely familiar with programming concepts like object-oriented programming (OOP), algorithms, and data structures. However, working with robots requires understanding hardware and electronics concepts, such as circuits, sensors, actuators, motors, and mechanical systems. In this documentation, we\'ll provide explanations and analogies to help you bridge the gap between software and hardware.","source":"@site/docs-software/module-1/ros2-fundamentals.md","sourceDirName":"module-1","slug":"/module-1/ros2-fundamentals","permalink":"/physical-ai-book/docs-software/module-1/ros2-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/sufyanarain/physical-ai-book/tree/main/website/docs-software/module-1/ros2-fundamentals.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to ROS 2","permalink":"/physical-ai-book/docs-software/module-1/ros2-intro"},"next":{"title":"Introduction to Robot Simulation","permalink":"/physical-ai-book/docs-software/module-2/simulation-intro"}}');var o=s(4848),r=s(8453);const a={sidebar_position:2},i="ROS 2 Fundamentals",l={},c=[{value:"Custom Messages",id:"custom-messages",level:2},{value:"Define a Custom Message",id:"define-a-custom-message",level:3},{value:"Using Custom Messages",id:"using-custom-messages",level:3},{value:"Launch Files",id:"launch-files",level:2},{value:"Parameters",id:"parameters",level:2},{value:"TF2 - Coordinate Transforms",id:"tf2---coordinate-transforms",level:2},{value:"URDF - Robot Description",id:"urdf---robot-description",level:2},{value:"Building a Mobile Robot Controller",id:"building-a-mobile-robot-controller",level:2},{value:"Quality of Service (QoS)",id:"quality-of-service-qos",level:2},{value:"Lifecycle Nodes",id:"lifecycle-nodes",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Real-World Application: Warehouse Robot",id:"real-world-application-warehouse-robot",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Resources",id:"resources",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"ros-2-fundamentals",children:"ROS 2 Fundamentals"})}),"\n",(0,o.jsx)(n.p,{children:"Deep dive into advanced ROS 2 concepts for building production-ready robotic systems. As a software developer, you're likely familiar with programming concepts like object-oriented programming (OOP), algorithms, and data structures. However, working with robots requires understanding hardware and electronics concepts, such as circuits, sensors, actuators, motors, and mechanical systems. In this documentation, we'll provide explanations and analogies to help you bridge the gap between software and hardware."}),"\n",(0,o.jsx)(n.h2,{id:"custom-messages",children:"Custom Messages"}),"\n",(0,o.jsx)(n.p,{children:"Create custom message types for specialized data. Think of custom messages like creating a new data structure in your programming language. Just as you would define a class or struct to hold specific data, custom messages allow you to define a new message type that can be used to communicate between nodes in your ROS 2 system."}),"\n",(0,o.jsx)(n.h3,{id:"define-a-custom-message",children:"Define a Custom Message"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-msg",children:"# RobotStatus.msg\nstring robot_id\nfloat32 battery_level\nfloat32 speed\ngeometry_msgs/Pose pose\nbool is_moving\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, we're defining a custom message called ",(0,o.jsx)(n.code,{children:"RobotStatus"})," that contains fields for the robot's ID, battery level, speed, pose, and a boolean indicating whether the robot is moving. This message can be used to publish the robot's status to other nodes in the system."]}),"\n",(0,o.jsx)(n.h3,{id:"using-custom-messages",children:"Using Custom Messages"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from my_interfaces.msg import RobotStatus\n\nclass StatusPublisher(Node):\n    def __init__(self):\n        super().__init__('status_publisher')\n        self.pub = self.create_publisher(RobotStatus, 'robot/status', 10)\n        \n    def publish_status(self):\n        msg = RobotStatus()\n        msg.robot_id = 'ROBOT_001'\n        msg.battery_level = 85.5\n        msg.speed = 1.2\n        msg.is_moving = True\n        self.pub.publish(msg)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here, we're creating a node that publishes the ",(0,o.jsx)(n.code,{children:"RobotStatus"})," message to a topic called ",(0,o.jsx)(n.code,{children:"robot/status"}),". We create an instance of the ",(0,o.jsx)(n.code,{children:"RobotStatus"})," message, fill in the fields, and then publish it to the topic."]}),"\n",(0,o.jsx)(n.h2,{id:"launch-files",children:"Launch Files"}),"\n",(0,o.jsx)(n.p,{children:"Launch files start multiple nodes with configuration. Think of launch files like a script that sets up and runs multiple programs at the same time. Just as you would write a script to automate tasks on your computer, launch files automate the process of starting and configuring nodes in your ROS 2 system."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# robot_launch.py\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='my_robot_pkg',\n            executable='sensor_node',\n            name='camera_sensor',\n            parameters=[{'frame_rate': 30}]\n        ),\n        Node(\n            package='my_robot_pkg',\n            executable='controller_node',\n            name='motor_controller',\n            parameters=[{'max_speed': 2.0}]\n        ),\n    ])\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, we're defining a launch file that starts two nodes: ",(0,o.jsx)(n.code,{children:"camera_sensor"})," and ",(0,o.jsx)(n.code,{children:"motor_controller"}),". We specify the package and executable for each node, as well as any parameters that need to be set."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Run:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"ros2 launch my_robot_pkg robot_launch.py\n"})}),"\n",(0,o.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,o.jsx)(n.p,{children:"Dynamic configuration without recompiling. Parameters are like variables that can be set and changed at runtime, without having to recompile your code. Just as you would use environment variables or command-line arguments to configure your program, parameters allow you to configure your ROS 2 nodes."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class ConfigurableNode(Node):\n    def __init__(self):\n        super().__init__('configurable_node')\n        \n        # Declare parameters\n        self.declare_parameter('update_rate', 10.0)\n        self.declare_parameter('robot_name', 'default_robot')\n        \n        # Get parameter values\n        self.rate = self.get_parameter('update_rate').value\n        self.name = self.get_parameter('robot_name').value\n        \n        self.get_logger().info(f'Rate: {self.rate}, Name: {self.name}')\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here, we're creating a node that declares two parameters: ",(0,o.jsx)(n.code,{children:"update_rate"})," and ",(0,o.jsx)(n.code,{children:"robot_name"}),". We get the values of these parameters and log them to the console."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Set parameters:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"ros2 run my_pkg node --ros-args -p update_rate:=20.0 -p robot_name:=RobotX\n"})}),"\n",(0,o.jsx)(n.h2,{id:"tf2---coordinate-transforms",children:"TF2 - Coordinate Transforms"}),"\n",(0,o.jsx)(n.p,{children:"TF2 manages coordinate frames for sensors and robot parts. Think of TF2 like a system that helps you keep track of where everything is in 3D space. Just as you would use a mapping system to navigate a city, TF2 helps your robot navigate its environment by managing coordinate frames."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from tf2_ros import TransformBroadcaster\nfrom geometry_msgs.msg import TransformStamped\n\nclass FramePublisher(Node):\n    def __init__(self):\n        super().__init__('frame_publisher')\n        self.br = TransformBroadcaster(self)\n        self.timer = self.create_timer(0.1, self.broadcast_transform)\n    \n    def broadcast_transform(self):\n        t = TransformStamped()\n        t.header.stamp = self.get_clock().now().to_msg()\n        t.header.frame_id = 'base_link'\n        t.child_frame_id = 'camera_link'\n        \n        # Position\n        t.transform.translation.x = 0.5\n        t.transform.translation.y = 0.0\n        t.transform.translation.z = 0.3\n        \n        # Rotation (quaternion)\n        t.transform.rotation.w = 1.0\n        \n        self.br.sendTransform(t)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, we're creating a node that publishes a transform between two frames: ",(0,o.jsx)(n.code,{children:"base_link"})," and ",(0,o.jsx)(n.code,{children:"camera_link"}),". We set the position and rotation of the transform and send it to the TF2 system."]}),"\n",(0,o.jsx)(n.h2,{id:"urdf---robot-description",children:"URDF - Robot Description"}),"\n",(0,o.jsx)(n.p,{children:"Unified Robot Description Format defines robot structure. Think of URDF like a blueprint for your robot. Just as you would use a blueprint to design and build a house, URDF allows you to define the structure and components of your robot."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_robot">\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.5 0.3 0.2"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 0.8 1"/>\n      </material>\n    </visual>\n  </link>\n  \n  \x3c!-- Camera Link --\x3e\n  <link name="camera_link">\n    <visual>\n      <geometry>\n        <cylinder length="0.1" radius="0.05"/>\n      </geometry>\n    </visual>\n  </link>\n  \n  \x3c!-- Joint connecting base to camera --\x3e\n  <joint name="camera_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="camera_link"/>\n    <origin xyz="0.25 0 0.15" rpy="0 0 0"/>\n  </joint>\n</robot>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, we're defining a simple robot with two links: ",(0,o.jsx)(n.code,{children:"base_link"})," and ",(0,o.jsx)(n.code,{children:"camera_link"}),". We define the visual properties of each link, as well as a joint that connects them."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Visualize in RViz:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"ros2 launch urdf_tutorial display.launch.py model:=simple_robot.urdf\n"})}),"\n",(0,o.jsx)(n.h2,{id:"building-a-mobile-robot-controller",children:"Building a Mobile Robot Controller"}),"\n",(0,o.jsx)(n.p,{children:"Complete example integrating multiple concepts. This example shows how to create a mobile robot controller that uses many of the concepts we've covered so far."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom nav_msgs.msg import Odometry\nimport math\n\nclass MobileRobotController(Node):\n    def __init__(self):\n        super().__init__('mobile_robot_controller')\n        \n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)\n        \n        # Subscribers\n        self.odom_sub = self.create_subscription(\n            Odometry, 'odom', self.odom_callback, 10\n        )\n        \n        # Parameters\n        self.declare_parameter('linear_speed', 0.5)\n        self.declare_parameter('angular_speed', 1.0)\n        \n        self.current_x = 0.0\n        self.current_y = 0.0\n        self.target_x = 5.0\n        self.target_y = 5.0\n        \n        self.timer = self.create_timer(0.1, self.control_loop)\n    \n    def odom_callback(self, msg):\n        self.current_x = msg.pose.pose.position.x\n        self.current_y = msg.pose.pose.position.y\n    \n    def control_loop(self):\n        # Calculate distance to target\n        dx = self.target_x - self.current_x\n        dy = self.target_y - self.current_y\n        distance = math.sqrt(dx**2 + dy**2)\n        \n        cmd = Twist()\n        \n        if distance > 0.1:  # Not at target\n            # Calculate angle to target\n            angle_to_target = math.atan2(dy, dx)\n            \n            cmd.linear.x = self.get_parameter('linear_speed').value\n            cmd.angular.z = angle_to_target\n        else:\n            cmd.linear.x = 0.0\n            cmd.angular.z = 0.0\n            self.get_logger().info('Target reached!')\n        \n        self.cmd_vel_pub.publish(cmd)\n\ndef main():\n    rclpy.init()\n    controller = MobileRobotController()\n    rclpy.spin(controller)\n    rclpy.shutdown()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"quality-of-service-qos",children:"Quality of Service (QoS)"}),"\n",(0,o.jsx)(n.p,{children:"Configure communication reliability. QoS is like setting the priority of your emails. Just as you would set the priority of an email to ensure it gets delivered quickly, QoS allows you to set the priority of your messages to ensure they get delivered reliably."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\n\n# Reliable communication (important data)\nreliable_qos = QoSProfile(\n    reliability=ReliabilityPolicy.RELIABLE,\n    durability=DurabilityPolicy.TRANSIENT_LOCAL,\n    depth=10\n)\n\n# Best effort (sensor data, can tolerate loss)\nsensor_qos = QoSProfile(\n    reliability=ReliabilityPolicy.BEST_EFFORT,\n    depth=10\n)\n\nself.pub = self.create_publisher(Image, 'camera/image', sensor_qos)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"lifecycle-nodes",children:"Lifecycle Nodes"}),"\n",(0,o.jsx)(n.p,{children:"Manage node states for robust systems. Lifecycle nodes are like a state machine that manages the state of your node. Just as you would use a state machine to manage the state of a complex system, lifecycle nodes allow you to manage the state of your node and ensure it's always in a valid state."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from rclpy.lifecycle import LifecycleNode, TransitionCallbackReturn\n\nclass ManagedNode(LifecycleNode):\n    def on_configure(self, state):\n        self.get_logger().info('Configuring...')\n        # Setup resources\n        return TransitionCallbackReturn.SUCCESS\n    \n    def on_activate(self, state):\n        self.get_logger().info('Activating...')\n        # Start operations\n        return TransitionCallbackReturn.SUCCESS\n    \n    def on_deactivate(self, state):\n        self.get_logger().info('Deactivating...')\n        # Pause operations\n        return TransitionCallbackReturn.SUCCESS\n    \n    def on_cleanup(self, state):\n        self.get_logger().info('Cleaning up...')\n        # Release resources\n        return TransitionCallbackReturn.SUCCESS\n"})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use Namespaces"}),": Organize multi-robot systems. Namespaces are like folders that help you organize your files. Just as you would use folders to organize your files, namespaces help you organize your nodes and topics."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Parameter Files"}),": Separate configuration from code. Parameter files are like configuration files that allow you to separate your configuration from your code. Just as you would use a configuration file to configure your program, parameter files allow you to configure your nodes."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Error Handling"}),": Always validate inputs and handle exceptions. Error handling is like having a safety net that catches any errors that might occur. Just as you would use try-catch blocks to handle exceptions in your code, error handling ensures that your node can recover from any errors that might occur."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Logging"}),": Use ROS 2 logging (DEBUG, INFO, WARN, ERROR, FATAL). Logging is like keeping a diary that records what's happening in your node. Just as you would use logging to debug your code, ROS 2 logging allows you to log messages at different levels of severity."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Testing"}),": Write unit tests with ",(0,o.jsx)(n.code,{children:"launch_testing"}),". Testing is like checking your work to make sure it's correct. Just as you would write unit tests to ensure your code is working correctly, ",(0,o.jsx)(n.code,{children:"launch_testing"})," allows you to write tests for your nodes."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"real-world-application-warehouse-robot",children:"Real-World Application: Warehouse Robot"}),"\n",(0,o.jsx)(n.p,{children:"Combining all concepts for a functional warehouse robot. This example shows how to create a warehouse robot that uses many of the concepts we've covered so far."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class WarehouseRobot(Node):\n    def __init__(self):\n        super().__init__('warehouse_robot')\n        \n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.status_pub = self.create_publisher(String, 'robot/status', 10)\n        \n        # Subscribers\n        self.laser_sub = self.create_subscription(\n            LaserScan, 'scan', self.laser_callback, 10\n        )\n        self.task_sub = self.create_subscription(\n            String, 'tasks', self.task_callback, 10\n        )\n        \n        # Services\n        self.emergency_stop_srv = self.create_service(\n            Trigger, 'emergency_stop', self.emergency_stop_callback\n        )\n        \n        # TF\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n        \n        # State\n        self.state = 'IDLE'  # IDLE, MOVING, LOADING, ERROR\n    \n    def laser_callback(self, msg):\n        # Obstacle avoidance logic\n        min_distance = min(msg.ranges)\n        if min_distance < 0.5:\n            self.stop()\n            self.get_logger().warn('Obstacle detected!')\n    \n    def task_callback(self, msg):\n        # Process new task\n        task = msg.data\n        self.get_logger().info(f'New task: {task}')\n        self.execute_task(task)\n    \n    def emergency_stop_callback(self, request, response):\n        self.stop()\n        self.state = 'ERROR'\n        response.success = True\n        response.message = 'Emergency stop activated'\n        return response\n"})}),"\n",(0,o.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(n.p,{children:["\u2705 ",(0,o.jsx)(n.strong,{children:"Custom messages"})," enable specialized data types",(0,o.jsx)(n.br,{}),"\n","\u2705 ",(0,o.jsx)(n.strong,{children:"Launch files"})," simplify multi-node systems",(0,o.jsx)(n.br,{}),"\n","\u2705 ",(0,o.jsx)(n.strong,{children:"Parameters"})," provide dynamic configuration",(0,o.jsx)(n.br,{}),"\n","\u2705 ",(0,o.jsx)(n.strong,{children:"TF2"})," manages coordinate transformations",(0,o.jsx)(n.br,{}),"\n","\u2705 ",(0,o.jsx)(n.strong,{children:"URDF"})," defines robot structure",(0,o.jsx)(n.br,{}),"\n","\u2705 ",(0,o.jsx)(n.strong,{children:"QoS"})," controls communication reliability"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Next Module:"})," ",(0,o.jsx)(n.a,{href:"../module-2/simulation-intro",children:"The Digital Twin (Gazebo & Unity) \u2192"})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials.html",children:"ROS 2 Tutorials"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://docs.ros2.org/humble/api/",children:"ROS 2 Humble API Docs"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/Tf2/Tf2-Main.html",children:"TF2 Tutorial"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);