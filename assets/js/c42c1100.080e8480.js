"use strict";(self.webpackChunkphysical_ai_textbook=self.webpackChunkphysical_ai_textbook||[]).push([[9129],{5178:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-2/simulation-intro","title":"Introduction to Robot Simulation","description":"Simulation is the bridge between theory and practice in robotics. Before deploying expensive hardware, we test in virtual environments called Digital Twins. Think of a digital twin like a prototype in the hardware world, where you can test and refine your design before manufacturing the final product.","source":"@site/docs-hardware/module-2/simulation-intro.md","sourceDirName":"module-2","slug":"/module-2/simulation-intro","permalink":"/physical-ai-book/docs-hardware/module-2/simulation-intro","draft":false,"unlisted":false,"editUrl":"https://github.com/sufyanarain/physical-ai-book/tree/main/website/docs-hardware/module-2/simulation-intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Fundamentals","permalink":"/physical-ai-book/docs-hardware/module-1/ros2-fundamentals"},"next":{"title":"Gazebo & Unity Integration","permalink":"/physical-ai-book/docs-hardware/module-2/gazebo-unity"}}');var a=i(4848),o=i(8453);const r={sidebar_position:1},t="Introduction to Robot Simulation",l={},d=[{value:"Why Simulate?",id:"why-simulate",level:2},{value:"Benefits",id:"benefits",level:3},{value:"Industry Standard Tools",id:"industry-standard-tools",level:3},{value:"Gazebo Classic vs. Gazebo (Ignition)",id:"gazebo-classic-vs-gazebo-ignition",level:2},{value:"Physics Engines",id:"physics-engines",level:2},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"Bullet",id:"bullet",level:3},{value:"DART (Dynamic Animation and Robotics Toolkit)",id:"dart-dynamic-animation-and-robotics-toolkit",level:3},{value:"Example: Physics Configuration",id:"example-physics-configuration",level:3},{value:"Creating Your First Gazebo World",id:"creating-your-first-gazebo-world",level:2},{value:"Simple World File",id:"simple-world-file",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:2},{value:"LiDAR (Laser Scanner)",id:"lidar-laser-scanner",level:3},{value:"Camera",id:"camera",level:3},{value:"IMU (Inertial Measurement Unit)",id:"imu-inertial-measurement-unit",level:3},{value:"Building a Mobile Robot Model",id:"building-a-mobile-robot-model",level:2},{value:"Integration with ROS 2",id:"integration-with-ros-2",level:2},{value:"Launch Gazebo with ROS 2",id:"launch-gazebo-with-ros-2",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2}];function c(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"introduction-to-robot-simulation",children:"Introduction to Robot Simulation"})}),"\n",(0,a.jsxs)(n.p,{children:["Simulation is the bridge between theory and practice in robotics. Before deploying expensive hardware, we test in virtual environments called ",(0,a.jsx)(n.strong,{children:"Digital Twins"}),". Think of a digital twin like a prototype in the hardware world, where you can test and refine your design before manufacturing the final product."]}),"\n",(0,a.jsx)(n.h2,{id:"why-simulate",children:"Why Simulate?"}),"\n",(0,a.jsx)(n.h3,{id:"benefits",children:"Benefits"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Aspect"}),(0,a.jsx)(n.th,{children:"Real Robot"}),(0,a.jsx)(n.th,{children:"Simulation"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Cost"})}),(0,a.jsx)(n.td,{children:"$10k-$100k+"}),(0,a.jsx)(n.td,{children:"Free"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Risk"})}),(0,a.jsx)(n.td,{children:"Hardware damage"}),(0,a.jsx)(n.td,{children:"Zero risk"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Iteration Speed"})}),(0,a.jsx)(n.td,{children:"Hours"}),(0,a.jsx)(n.td,{children:"Seconds"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Testing Scenarios"})}),(0,a.jsx)(n.td,{children:"Limited"}),(0,a.jsx)(n.td,{children:"Unlimited"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Debugging"})}),(0,a.jsx)(n.td,{children:"Difficult"}),(0,a.jsx)(n.td,{children:"Full visibility"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:"Simulation offers numerous benefits, including reduced costs, minimized risk, and accelerated iteration. In the hardware world, you can think of simulation as a way to test your design without wasting materials or damaging equipment."}),"\n",(0,a.jsx)(n.h3,{id:"industry-standard-tools",children:"Industry Standard Tools"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Gazebo"}),": Physics simulation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Unity"}),": High-fidelity rendering"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Isaac Sim"}),": NVIDIA's photorealistic platform"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Webots"}),": Multi-robot simulation"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"These tools provide a range of features, from basic physics simulations to advanced rendering and multi-robot simulations. Gazebo, in particular, is a popular choice for robotics simulation due to its flexibility and customizability."}),"\n",(0,a.jsx)(n.h2,{id:"gazebo-classic-vs-gazebo-ignition",children:"Gazebo Classic vs. Gazebo (Ignition)"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Gazebo Classic"})," is being phased out. ",(0,a.jsx)(n.strong,{children:"New Gazebo (formerly Ignition)"})," offers:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Better performance"}),"\n",(0,a.jsx)(n.li,{children:"Improved physics engines"}),"\n",(0,a.jsx)(n.li,{children:"Enhanced sensor models"}),"\n",(0,a.jsx)(n.li,{children:"Web-based visualization"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The new Gazebo (Ignition) provides significant improvements over the classic version, including better performance, more accurate physics simulations, and enhanced sensor models. This is similar to upgrading from an older hardware component to a newer, more efficient one."}),"\n",(0,a.jsx)(n.h2,{id:"physics-engines",children:"Physics Engines"}),"\n",(0,a.jsx)(n.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,a.jsx)(n.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Default in Gazebo Classic"}),"\n",(0,a.jsx)(n.li,{children:"Good for basic simulations"}),"\n",(0,a.jsx)(n.li,{children:"Moderate accuracy"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"bullet",children:"Bullet"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Fast collision detection"}),"\n",(0,a.jsx)(n.li,{children:"Used in games and robotics"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"dart-dynamic-animation-and-robotics-toolkit",children:"DART (Dynamic Animation and Robotics Toolkit)"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"High accuracy"}),"\n",(0,a.jsx)(n.li,{children:"Complex contact dynamics"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"These physics engines can be thought of as different algorithms for simulating real-world physics. Each engine has its strengths and weaknesses, and the choice of engine depends on the specific requirements of your simulation."}),"\n",(0,a.jsx)(n.h3,{id:"example-physics-configuration",children:"Example: Physics Configuration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<world name="default">\n  <physics type="ode">\n    <real_time_update_rate>1000</real_time_update_rate>\n    <max_step_size>0.001</max_step_size>\n  </physics>\n  \n  <gravity>0 0 -9.81</gravity>\n</world>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This code snippet shows how to configure the physics engine in Gazebo. The ",(0,a.jsx)(n.code,{children:"physics"})," tag specifies the type of physics engine to use (in this case, ODE), and the ",(0,a.jsx)(n.code,{children:"real_time_update_rate"})," and ",(0,a.jsx)(n.code,{children:"max_step_size"})," tags control the simulation's time step and update rate."]}),"\n",(0,a.jsx)(n.h2,{id:"creating-your-first-gazebo-world",children:"Creating Your First Gazebo World"}),"\n",(0,a.jsx)(n.h3,{id:"simple-world-file",children:"Simple World File"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.6">\n  <world name="robot_world">\n    \x3c!-- Sun for lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n    \n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n    \n    \x3c!-- Add a box obstacle --\x3e\n    <model name="box">\n      <pose>2 0 0.5 0 0 0</pose>\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0 0 1</ambient>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This SDF file defines a simple world with a sun, ground plane, and a box obstacle. The ",(0,a.jsx)(n.code,{children:"model"})," tag defines the box's pose, collision, and visual properties."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Launch:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"gazebo robot_world.world\n"})}),"\n",(0,a.jsx)(n.p,{children:"This command launches the Gazebo simulation with the specified world file."}),"\n",(0,a.jsx)(n.h2,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,a.jsx)(n.h3,{id:"lidar-laser-scanner",children:"LiDAR (Laser Scanner)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<sensor type="ray" name="lidar">\n  <pose>0 0 0.2 0 0 0</pose>\n  <visualize>true</visualize>\n  <update_rate>10</update_rate>\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>360</samples>\n        <resolution>1</resolution>\n        <min_angle>-3.14159</min_angle>\n        <max_angle>3.14159</max_angle>\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n  </ray>\n  <plugin name="laser_controller" filename="libgazebo_ros_ray_sensor.so">\n    <ros>\n      <namespace>/robot</namespace>\n      <remapping>~/out:=scan</remapping>\n    </ros>\n    <output_type>sensor_msgs/LaserScan</output_type>\n  </plugin>\n</sensor>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This code snippet defines a LiDAR sensor with a horizontal scan range of 360 degrees and a resolution of 1 degree. The ",(0,a.jsx)(n.code,{children:"plugin"})," tag specifies the ROS plugin for the LiDAR sensor."]}),"\n",(0,a.jsx)(n.h3,{id:"camera",children:"Camera"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<sensor type="camera" name="camera1">\n  <update_rate>30.0</update_rate>\n  <camera>\n    <horizontal_fov>1.3962634</horizontal_fov>\n    <image>\n      <width>1920</width>\n      <height>1080</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.02</near>\n      <far>300</far>\n    </clip>\n  </camera>\n  <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n    <ros>\n      <namespace>/robot</namespace>\n      <remapping>image_raw:=camera/image</remapping>\n    </ros>\n  </plugin>\n</sensor>\n'})}),"\n",(0,a.jsx)(n.p,{children:"This code snippet defines a camera sensor with a horizontal field of view (FOV) of 1.396 radians and an image resolution of 1920x1080 pixels."}),"\n",(0,a.jsx)(n.h3,{id:"imu-inertial-measurement-unit",children:"IMU (Inertial Measurement Unit)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<sensor name="imu_sensor" type="imu">\n  <update_rate>100</update_rate>\n  <imu>\n    <angular_velocity>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n        </noise>\n      </x>\n    </angular_velocity>\n    <linear_acceleration>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n        </noise>\n      </x>\n    </linear_acceleration>\n  </imu>\n  <plugin name="imu_plugin" filename="libgazebo_ros_imu_sensor.so">\n    <ros>\n      <namespace>/robot</namespace>\n      <remapping>~/out:=imu</remapping>\n    </ros>\n  </plugin>\n</sensor>\n'})}),"\n",(0,a.jsx)(n.p,{children:"This code snippet defines an IMU sensor with Gaussian noise models for angular velocity and linear acceleration."}),"\n",(0,a.jsx)(n.h2,{id:"building-a-mobile-robot-model",children:"Building a Mobile Robot Model"}),"\n",(0,a.jsx)(n.p,{children:"Complete SDF for a differential drive robot:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.6">\n  <model name="diff_drive_robot">\n    \x3c!-- Base Link --\x3e\n    <link name="base_link">\n      <inertial>\n        <mass>10</mass>\n        <inertia>\n          <ixx>0.2</ixx>\n          <iyy>0.2</iyy>\n          <izz>0.4</izz>\n        </inertia>\n      </inertial>\n      \n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.5 0.3 0.2</size>\n          </box>\n        </geometry>\n      </collision>\n      \n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.5 0.3 0.2</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0 0 0.8 1</ambient>\n        </material>\n      </visual>\n    </link>\n    \n    \x3c!-- Left Wheel --\x3e\n    <link name="left_wheel">\n      <pose>0 0.2 0 -1.5707 0 0</pose>\n      <inertial>\n        <mass>1</mass>\n      </inertial>\n      <collision name="collision">\n        <geometry>\n          <cylinder>\n            <radius>0.1</radius>\n            <length>0.05</length>\n          </cylinder>\n        </geometry>\n      </collision>\n      <visual name="visual">\n        <geometry>\n          <cylinder>\n            <radius>0.1</radius>\n            <length>0.05</length>\n          </cylinder>\n        </geometry>\n      </visual>\n    </link>\n    \n    \x3c!-- Joint for left wheel --\x3e\n    <joint name="left_wheel_joint" type="revolute">\n      <parent>base_link</parent>\n      <child>left_wheel</child>\n      <axis>\n        <xyz>0 1 0</xyz>\n      </axis>\n    </joint>\n    \n    \x3c!-- Differential Drive Plugin --\x3e\n    <plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">\n      <ros>\n        <namespace>/robot</namespace>\n      </ros>\n      <left_joint>left_wheel_joint</left_joint>\n      <right_joint>right_wheel_joint</right_joint>\n      <wheel_separation>0.4</wheel_separation>\n      <wheel_diameter>0.2</wheel_diameter>\n      <max_wheel_torque>20</max_wheel_torque>\n      <command_topic>cmd_vel</command_topic>\n      <odometry_topic>odom</odometry_topic>\n      <odometry_frame>odom</odometry_frame>\n      <robot_base_frame>base_link</robot_base_frame>\n    </plugin>\n  </model>\n</sdf>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This SDF file defines a differential drive robot with two wheels and a base link. The ",(0,a.jsx)(n.code,{children:"plugin"})," tag specifies the ROS plugin for the differential drive controller."]}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-ros-2",children:"Integration with ROS 2"}),"\n",(0,a.jsx)(n.h3,{id:"launch-gazebo-with-ros-2",children:"Launch Gazebo with ROS 2"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        IncludeLaunchDescription(\n            'gazebo_ros/launch/gazebo.launch.py',\n        ),\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=['-entity', 'robot', '-file', 'robot.sdf'],\n        ),\n    ])\n"})}),"\n",(0,a.jsx)(n.p,{children:"This code snippet defines a ROS 2 launch file that launches Gazebo and spawns a robot entity."}),"\n",(0,a.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(n.p,{children:["\u2705 Simulation saves time and money",(0,a.jsx)(n.br,{}),"\n","\u2705 Gazebo provides realistic physics and sensors",(0,a.jsx)(n.br,{}),"\n","\u2705 SDF format defines robot models",(0,a.jsx)(n.br,{}),"\n","\u2705 ROS 2 integration enables seamless testing"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Next:"})," ",(0,a.jsx)(n.a,{href:"./gazebo-unity",children:"Gazebo & Unity Advanced \u2192"})]}),"\n",(0,a.jsx)(n.p,{children:"In this tutorial, we covered the basics of robot simulation using Gazebo and ROS 2. We learned how to create a simple world, add sensors and models, and integrate with ROS 2. We also discussed the benefits of simulation and the different physics engines available in Gazebo. With this knowledge, you can start building your own robot simulations and testing your algorithms in a virtual environment."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>t});var s=i(6540);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);