"use strict";(self.webpackChunkphysical_ai_textbook=self.webpackChunkphysical_ai_textbook||[]).push([[6196],{5993:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"module-2/simulation-intro","title":"Introduction to Robot Simulation","description":"Simulation is the bridge between theory and practice in robotics. Before deploying expensive hardware, we test in virtual environments called Digital Twins. Think of a Digital Twin like a virtual prototype of your robot, where you can test and refine its behavior without the risks and costs associated with physical prototypes.","source":"@site/docs-software/module-2/simulation-intro.md","sourceDirName":"module-2","slug":"/module-2/simulation-intro","permalink":"/physical-ai-book/docs-software/module-2/simulation-intro","draft":false,"unlisted":false,"editUrl":"https://github.com/sufyanarain/physical-ai-book/tree/main/website/docs-software/module-2/simulation-intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Fundamentals","permalink":"/physical-ai-book/docs-software/module-1/ros2-fundamentals"},"next":{"title":"Gazebo & Unity Integration","permalink":"/physical-ai-book/docs-software/module-2/gazebo-unity"}}');var s=i(4848),o=i(8453);const t={sidebar_position:1},r="Introduction to Robot Simulation",l={},d=[{value:"Why Simulate?",id:"why-simulate",level:2},{value:"Benefits",id:"benefits",level:3},{value:"Industry Standard Tools",id:"industry-standard-tools",level:3},{value:"Gazebo Classic vs. Gazebo (Ignition)",id:"gazebo-classic-vs-gazebo-ignition",level:2},{value:"Physics Engines",id:"physics-engines",level:2},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"Bullet",id:"bullet",level:3},{value:"DART (Dynamic Animation and Robotics Toolkit)",id:"dart-dynamic-animation-and-robotics-toolkit",level:3},{value:"Example: Physics Configuration",id:"example-physics-configuration",level:3},{value:"Creating Your First Gazebo World",id:"creating-your-first-gazebo-world",level:2},{value:"Simple World File",id:"simple-world-file",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:2},{value:"LiDAR (Laser Scanner)",id:"lidar-laser-scanner",level:3},{value:"Camera",id:"camera",level:3},{value:"IMU (Inertial Measurement Unit)",id:"imu-inertial-measurement-unit",level:3},{value:"Building a Mobile Robot Model",id:"building-a-mobile-robot-model",level:2},{value:"Integration with ROS 2",id:"integration-with-ros-2",level:2},{value:"Launch Gazebo with ROS 2",id:"launch-gazebo-with-ros-2",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2}];function c(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"introduction-to-robot-simulation",children:"Introduction to Robot Simulation"})}),"\n",(0,s.jsxs)(n.p,{children:["Simulation is the bridge between theory and practice in robotics. Before deploying expensive hardware, we test in virtual environments called ",(0,s.jsx)(n.strong,{children:"Digital Twins"}),". Think of a Digital Twin like a virtual prototype of your robot, where you can test and refine its behavior without the risks and costs associated with physical prototypes."]}),"\n",(0,s.jsx)(n.h2,{id:"why-simulate",children:"Why Simulate?"}),"\n",(0,s.jsx)(n.h3,{id:"benefits",children:"Benefits"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Aspect"}),(0,s.jsx)(n.th,{children:"Real Robot"}),(0,s.jsx)(n.th,{children:"Simulation"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Cost"})}),(0,s.jsx)(n.td,{children:"$10k-$100k+"}),(0,s.jsx)(n.td,{children:"Free"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Risk"})}),(0,s.jsx)(n.td,{children:"Hardware damage"}),(0,s.jsx)(n.td,{children:"Zero risk"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Iteration Speed"})}),(0,s.jsx)(n.td,{children:"Hours"}),(0,s.jsx)(n.td,{children:"Seconds"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Testing Scenarios"})}),(0,s.jsx)(n.td,{children:"Limited"}),(0,s.jsx)(n.td,{children:"Unlimited"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Debugging"})}),(0,s.jsx)(n.td,{children:"Difficult"}),(0,s.jsx)(n.td,{children:"Full visibility"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Simulation offers numerous benefits, including reduced costs, minimized risk, faster iteration, and enhanced debugging capabilities. This is similar to how software developers use virtual environments and debuggers to test and refine their code."}),"\n",(0,s.jsx)(n.h3,{id:"industry-standard-tools",children:"Industry Standard Tools"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo"}),": Physics simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unity"}),": High-fidelity rendering"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isaac Sim"}),": NVIDIA's photorealistic platform"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Webots"}),": Multi-robot simulation"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These tools provide a range of features, from basic physics simulations to advanced rendering and multi-robot simulations. Each tool has its strengths and is suited for different types of projects."}),"\n",(0,s.jsx)(n.h2,{id:"gazebo-classic-vs-gazebo-ignition",children:"Gazebo Classic vs. Gazebo (Ignition)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Gazebo Classic"})," is being phased out. ",(0,s.jsx)(n.strong,{children:"New Gazebo (formerly Ignition)"})," offers:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Better performance"}),"\n",(0,s.jsx)(n.li,{children:"Improved physics engines"}),"\n",(0,s.jsx)(n.li,{children:"Enhanced sensor models"}),"\n",(0,s.jsx)(n.li,{children:"Web-based visualization"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The new Gazebo offers significant improvements over the classic version, including better performance, more accurate physics engines, and enhanced sensor models. This is similar to how software frameworks evolve over time, with new versions offering improved performance and features."}),"\n",(0,s.jsx)(n.h2,{id:"physics-engines",children:"Physics Engines"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,s.jsx)(n.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Default in Gazebo Classic"}),"\n",(0,s.jsx)(n.li,{children:"Good for basic simulations"}),"\n",(0,s.jsx)(n.li,{children:"Moderate accuracy"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"bullet",children:"Bullet"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fast collision detection"}),"\n",(0,s.jsx)(n.li,{children:"Used in games and robotics"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dart-dynamic-animation-and-robotics-toolkit",children:"DART (Dynamic Animation and Robotics Toolkit)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"High accuracy"}),"\n",(0,s.jsx)(n.li,{children:"Complex contact dynamics"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Physics engines are responsible for simulating the physical behavior of objects in the virtual environment. They take into account factors like gravity, friction, and collisions to create a realistic simulation. This is similar to how game engines use physics engines to simulate realistic gameplay."}),"\n",(0,s.jsx)(n.h3,{id:"example-physics-configuration",children:"Example: Physics Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<world name="default">\n  <physics type="ode">\n    <real_time_update_rate>1000</real_time_update_rate>\n    <max_step_size>0.001</max_step_size>\n  </physics>\n  \n  <gravity>0 0 -9.81</gravity>\n</world>\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this example, we're configuring the physics engine to use the ODE engine, with a real-time update rate of 1000 and a maximum step size of 0.001. We're also setting the gravity to 9.81 m/s^2, which is the standard value for Earth's gravity."}),"\n",(0,s.jsx)(n.h2,{id:"creating-your-first-gazebo-world",children:"Creating Your First Gazebo World"}),"\n",(0,s.jsx)(n.h3,{id:"simple-world-file",children:"Simple World File"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.6">\n  <world name="robot_world">\n    \x3c!-- Sun for lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n    \n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n    \n    \x3c!-- Add a box obstacle --\x3e\n    <model name="box">\n      <pose>2 0 0.5 0 0 0</pose>\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0 0 1</ambient>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this example, we're creating a simple world with a sun, ground plane, and a box obstacle. The box is defined with a pose, collision geometry, and visual properties."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Launch:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"gazebo robot_world.world\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To launch the world, we simply run the ",(0,s.jsx)(n.code,{children:"gazebo"})," command with the world file as an argument."]}),"\n",(0,s.jsx)(n.h2,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,s.jsx)(n.h3,{id:"lidar-laser-scanner",children:"LiDAR (Laser Scanner)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<sensor type="ray" name="lidar">\n  <pose>0 0 0.2 0 0 0</pose>\n  <visualize>true</visualize>\n  <update_rate>10</update_rate>\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>360</samples>\n        <resolution>1</resolution>\n        <min_angle>-3.14159</min_angle>\n        <max_angle>3.14159</max_angle>\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n  </ray>\n  <plugin name="laser_controller" filename="libgazebo_ros_ray_sensor.so">\n    <ros>\n      <namespace>/robot</namespace>\n      <remapping>~/out:=scan</remapping>\n    </ros>\n    <output_type>sensor_msgs/LaserScan</output_type>\n  </plugin>\n</sensor>\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this example, we're defining a LiDAR sensor with a pose, update rate, and ray properties. The sensor is configured to produce a 360-degree scan with a resolution of 1 degree and a range of 0.1 to 30 meters."}),"\n",(0,s.jsx)(n.h3,{id:"camera",children:"Camera"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<sensor type="camera" name="camera1">\n  <update_rate>30.0</update_rate>\n  <camera>\n    <horizontal_fov>1.3962634</horizontal_fov>\n    <image>\n      <width>1920</width>\n      <height>1080</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.02</near>\n      <far>300</far>\n    </clip>\n  </camera>\n  <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n    <ros>\n      <namespace>/robot</namespace>\n      <remapping>image_raw:=camera/image</remapping>\n    </ros>\n  </plugin>\n</sensor>\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this example, we're defining a camera sensor with an update rate, horizontal field of view, image properties, and clip properties. The sensor is configured to produce a 1920x1080 image with a format of R8G8B8."}),"\n",(0,s.jsx)(n.h3,{id:"imu-inertial-measurement-unit",children:"IMU (Inertial Measurement Unit)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<sensor name="imu_sensor" type="imu">\n  <update_rate>100</update_rate>\n  <imu>\n    <angular_velocity>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n        </noise>\n      </x>\n    </angular_velocity>\n    <linear_acceleration>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n        </noise>\n      </x>\n    </linear_acceleration>\n  </imu>\n  <plugin name="imu_plugin" filename="libgazebo_ros_imu_sensor.so">\n    <ros>\n      <namespace>/robot</namespace>\n      <remapping>~/out:=imu</remapping>\n    </ros>\n  </plugin>\n</sensor>\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this example, we're defining an IMU sensor with an update rate, angular velocity, and linear acceleration properties. The sensor is configured to produce a Gaussian noise model with a mean of 0 and a standard deviation of 2e-4 for the angular velocity and 1.7e-2 for the linear acceleration."}),"\n",(0,s.jsx)(n.h2,{id:"building-a-mobile-robot-model",children:"Building a Mobile Robot Model"}),"\n",(0,s.jsx)(n.p,{children:"Complete SDF for a differential drive robot:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.6">\n  <model name="diff_drive_robot">\n    \x3c!-- Base Link --\x3e\n    <link name="base_link">\n      <inertial>\n        <mass>10</mass>\n        <inertia>\n          <ixx>0.2</ixx>\n          <iyy>0.2</iyy>\n          <izz>0.4</izz>\n        </inertia>\n      </inertial>\n      \n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.5 0.3 0.2</size>\n          </box>\n        </geometry>\n      </collision>\n      \n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.5 0.3 0.2</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0 0 0.8 1</ambient>\n        </material>\n      </visual>\n    </link>\n    \n    \x3c!-- Left Wheel --\x3e\n    <link name="left_wheel">\n      <pose>0 0.2 0 -1.5707 0 0</pose>\n      <inertial>\n        <mass>1</mass>\n      </inertial>\n      <collision name="collision">\n        <geometry>\n          <cylinder>\n            <radius>0.1</radius>\n            <length>0.05</length>\n          </cylinder>\n        </geometry>\n      </collision>\n      <visual name="visual">\n        <geometry>\n          <cylinder>\n            <radius>0.1</radius>\n            <length>0.05</length>\n          </cylinder>\n        </geometry>\n      </visual>\n    </link>\n    \n    \x3c!-- Joint for left wheel --\x3e\n    <joint name="left_wheel_joint" type="revolute">\n      <parent>base_link</parent>\n      <child>left_wheel</child>\n      <axis>\n        <xyz>0 1 0</xyz>\n      </axis>\n    </joint>\n    \n    \x3c!-- Differential Drive Plugin --\x3e\n    <plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">\n      <ros>\n        <namespace>/robot</namespace>\n      </ros>\n      <left_joint>left_wheel_joint</left_joint>\n      <right_joint>right_wheel_joint</right_joint>\n      <wheel_separation>0.4</wheel_separation>\n      <wheel_diameter>0.2</wheel_diameter>\n      <max_wheel_torque>20</max_wheel_torque>\n      <command_topic>cmd_vel</command_topic>\n      <odometry_topic>odom</odometry_topic>\n      <odometry_frame>odom</odometry_frame>\n      <robot_base_frame>base_link</robot_base_frame>\n    </plugin>\n  </model>\n</sdf>\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this example, we're defining a differential drive robot with a base link, left wheel, and right wheel. The robot has a mass of 10 kg and a inertia tensor. The left wheel has a mass of 1 kg and a collision geometry. The joint between the base link and the left wheel is a revolute joint with an axis of rotation along the y-axis."}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-ros-2",children:"Integration with ROS 2"}),"\n",(0,s.jsx)(n.h3,{id:"launch-gazebo-with-ros-2",children:"Launch Gazebo with ROS 2"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        IncludeLaunchDescription(\n            'gazebo_ros/launch/gazebo.launch.py',\n        ),\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=['-entity', 'robot', '-file', 'robot.sdf'],\n        ),\n    ])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we're launching Gazebo with ROS 2 using the ",(0,s.jsx)(n.code,{children:"launch"})," module. We're including the ",(0,s.jsx)(n.code,{children:"gazebo.launch.py"})," file and spawning the robot entity using the ",(0,s.jsx)(n.code,{children:"spawn_entity.py"})," executable."]}),"\n",(0,s.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 Simulation saves time and money",(0,s.jsx)(n.br,{}),"\n","\u2705 Gazebo provides realistic physics and sensors",(0,s.jsx)(n.br,{}),"\n","\u2705 SDF format defines robot models",(0,s.jsx)(n.br,{}),"\n","\u2705 ROS 2 integration enables seamless testing"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Next:"})," ",(0,s.jsx)(n.a,{href:"./gazebo-unity",children:"Gazebo & Unity Advanced \u2192"})]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>r});var a=i(6540);const s={},o=a.createContext(s);function t(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);